/*==============================================================================================
| Project	: Digital Move
|
| File		: main.cpp
|
| Purpose	: メインループ
|
| Compiler	: ARM - 
|
| History	: Version	Date		Content											Author
|			  V*.**		2018/--/--	First Edition									N.Ishikawa
+==============================================================================================*/
#include "common.h"
#include "gram.h"

#include "main.h"
#include "boot.h"
#include "cmd_act.h"
#include "io.h"
#include "needle.h"


/*==============================================================================================
| Prototype
+==============================================================================================*/
int main(void);
void dec_recv(void);

void interrupt_motora(void);
void interrupt_motorb(void);
void interrupt_motorc(void);
void interrupt_motord(void);
void interrupt_fall_led1(void);
void interrupt_rise_led1(void);
void interrupt_fall_led2(void);
void interrupt_rise_led2(void);

#if (CALSELECT & CALH296)
void interrupt_rise_decena(void);
void interrupt_fall_decena(void);
void interrupt_rise_dectck(void);
#endif

void calc_motcnt(MOTPARAM *ptr, uchar dir);


/*==============================================================================================
| Function
+==============================================================================================*/
/*======================================================================================
| Declaration :	main
| Description : メインループ
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
int main(void)
{
	boot();													// 起動処理
	
	while(1){
		cmd_recv();											// コマンド受信処理
		cmd_send();											// コマンド送信処理
		dec_recv();											// デコードIC受信処理
		//lcd_act();											// LCD出力処理
	}
}


/*==============================================================================================
| デコードIC受信処理
+==============================================================================================*/
/*======================================================================================
| Declaration :	dec_recv
| Description : デコードIC受信処理(デコードIC使用Calのみ)
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void dec_recv(void)
{
	if(interrupt._decrecv){									// 針検パラメータ受信 ?
		__disable_irq();									// 割込み禁止
		interrupt._decrecv = 0;
		
		switch(decparam.b._ledsel){							// 指定CHの針検実施(0:1ch, 1:2ch) => 穴検出 ?
		case LEDCH1:										// LED CH1 ?
			start_detect_hole(NDETMULTI);					// 複合針検実施
			break;
		case LEDCH2:										// LED CH2 ?
			start_detect_hole(NDETSINGLE);					// 単独針検実施
			break;
		default:											// LED CH3 or CH4 ?
			break;
		}
		__enable_irq();										// 割込み許可
	}
}


/*==============================================================================================
| Interrupt
+==============================================================================================*/
/*======================================================================================
| Declaration :	interrupt_motora
| Description : モータA 割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_motora(void)
{
	MOTPARAM *ptr;
	
	if(!MOTORAINT_P) return;								// ゴミ除去
	//ptr = &motprm[port_assign[MOTPORT1].motid];				// 
	ptr = &motprm[SELMOTOR_A];								// Motor A パラメータ
	if(ptr->max){											// パラメータあり ?
		if(!MOTORADIR_P){									// 正転 ?
			calc_motcnt(ptr, 1);
		}
		else {												// 逆転 ?
			calc_motcnt(ptr, 0);
		}
	}
}

/*======================================================================================
| Declaration :	interrupt_motorb
| Description : モータB 割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_motorb(void)
{
	MOTPARAM *ptr;
	
	if(!MOTORBINT_P) return;								// ゴミ除去
	//ptr = &motprm[port_assign[MOTPORT2].motid];				// 
	ptr = &motprm[SELMOTOR_B];								// Motor B パラメータ
	if(ptr->max){											// パラメータあり ?
		if(!MOTORBDIR_P){									// 正転 ?
			calc_motcnt(ptr, 1);
		}
		else {												// 逆転 ?
			calc_motcnt(ptr, 0);
		}
	}
}

/*======================================================================================
| Declaration :	interrupt_motorc
| Description : モータC 割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_motorc(void)
{
#if !(CALSELECT)											// General ?
	MOTPARAM *ptr;
	
	if(!MOTORCINT_P) return;								// ゴミ除去
	ptr = &motprm[SELMOTOR_C];								// Motor C パラメータ
	if(ptr->max){											// パラメータあり ?
		if(!MOTORCDIR_P){									// 正転 ?
			calc_motcnt(ptr, 1);
		}
		else {												// 逆転 ?
			calc_motcnt(ptr, 0);
		}
	}
#endif
}

/*======================================================================================
| Declaration :	interrupt_motord
| Description : モータD 割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_motord(void)
{
#if !(CALSELECT)											// General ?
	MOTPARAM *ptr;
	
	if(!MOTORDINT_P) return;								// ゴミ除去
	ptr = &motprm[SELMOTOR_D];								// Motor D パラメータ
	if(ptr->max){											// パラメータあり ?
		if(!MOTORDDIR_P){									// 正転 ?
			calc_motcnt(ptr, 1);
		}
		else {												// 逆転 ?
			calc_motcnt(ptr, 0);
		}
	}
#endif
}

/*======================================================================================
| Declaration :	calc_motcnt
| Description : モータカウント算出
| Parameters  :	MOTPARAM *ptr -> 
|				uchar dir	  -> 
| Returns	  : n/a
+======================================================================================*/
void calc_motcnt(MOTPARAM *ptr, uchar dir)
{
	if(dir){
		ptr->cnt++;
		if(ptr->cnt > ptr->max - 1){
			ptr->cnt = 0;
		}
	}
	else{
		if(!ptr->cnt){
			ptr->cnt = ptr->max;
		}
		ptr->cnt--;
	}
	
	//syssts.lcdevent = LCD_MOTOR;
}


/*======================================================================================
| Declaration :	interrupt_fall_led1
| Description : Port13(LED1)立下り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_fall_led1(void)
{
	// periled._ledsel = port割当て
	switch(periled._ledsel){								// 指定CHの針検実施(0:1ch, 1:2ch)
	case LEDCH1:											// LED CH1 ?
		start_detect_hole(NDETSINGLE);						// 単独針検実施
		break;
	case LEDCH2:											// LED CH2 ?
		start_detect_hole(NDETMULTI);						// 複合針検実施
		break;
	default:												// LED CH3 or CH4 ?
		break;
	}
}

/*======================================================================================
| Declaration :	interrupt_rise_led1
| Description : Port13(LED1)立上り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_rise_led1(void)
{
	stop_detect_hole();										// 針検停止
}

/*======================================================================================
| Declaration :	interrupt_fall_led2
| Description : Port14(LED2)立下り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_fall_led2(void)
{
	// periled._ledsel = port割当て
	switch(periled._ledsel){								// 指定CHの針検実施(0:1ch, 1:2ch)
	case LEDCH1:											// LED CH1 ?
		start_detect_hole(NDETSINGLE);						// 単独針検実施
		break;
	case LEDCH2:											// LED CH2 ?
		start_detect_hole(NDETMULTI);						// 複合針検実施
		break;
	default:												// LED CH3 or CH4 ?
		break;
	}
}

/*======================================================================================
| Declaration :	interrupt_rise_led2
| Description : Port14(LED2)立上り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_rise_led2(void)
{
	stop_detect_hole();										// 針検停止
}

#if (CALSELECT & CALH296)
/*======================================================================================
| Declaration :	interrupt_rise_decena
| Description : Port9(ENA)立上り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_rise_decena(void)
{
	//*(ulong*)&decparam = 0;
	decparam.dword = 0;										// デコードIC針検パラメータクリア
	deccnt = 0;												// デコードIC受信カウンタクリア
}

/*======================================================================================
| Declaration :	interrupt_fall_decena
| Description : Port9(ENA)立下り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_fall_decena(void)
{

}

/*======================================================================================
| Declaration :	interrupt_rise_dectck
| Description : Port10(CLK)立上り割り込み
| Parameters  :	n/a
| Returns	  : n/a
+======================================================================================*/
void interrupt_rise_dectck(void)
{
	if(DENAINT_P){											// DENA => H ?
		if(++deccnt < 25){									// bit23-0:針検データ
			decparam.dword <<= 1;
			if(DDATA_P){									// DDATA => H ?
				//*(ulong*)&decparam |= 1;
				decparam.dword |= 1;
			}
		}
		else{												// bit24:針検動作結果出力要求
			if(decparam.b._type == 1 || !decparam.b._type){	// LLH or LLL ?
				interrupt._decrecv = 1;						// 針検パラメータ受信
			}
		}
	}
}
#endif


